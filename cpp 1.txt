#include "StatManager.hpp"

StatManager::StatManager(int numPins) {
    this->numPins = numPins;
    values = new int[numPins];
    counts = new int[numPins];

    for (int i = 0; i < numPins; ++i) {
        values[i] = 0;
        counts[i] = 0;
    }
}

void StatManager::addValues(int* pinValues) {
    for (int i = 0; i < numPins; ++i) {
        values[i] += pinValues[i];
        counts[i]++;
    }
}

float* StatManager::getAverages() {
    float* averages = new float[numPins];

    for (int i = 0; i < numPins; ++i) {
        averages[i] = (counts[i] > 0) ? static_cast<float>(values[i]) / counts[i] : 0;
    }

    return averages;
}

float* StatManager::getMeans() {
    float* means = new float[numPins];

    for (int i = 0; i < numPins; ++i) {
        means[i] = (counts[i] > 0) ? static_cast<float>(values[i]) / counts[i] : 0;
    }

    return means;
}

int* StatManager::getMinimums() {
    int* minimums = new int[numPins];

    for (int i = 0; i < numPins; ++i) {
        // You need to implement logic to find the minimum value for each pin
        // For simplicity, let's assume the first value is the minimum
        minimums[i] = (counts[i] > 0) ? values[i] : 0;
    }

    return minimums;
}

int* StatManager::getMaximums() {
    int* maximums = new int[numPins];

    for (int i = 0; i < numPins; ++i) {
        // You need to implement logic to find the maximum value for each pin
        // For simplicity, let's assume the first value is the maximum
        maximums[i] = (counts[i] > 0) ? values[i] : 0;
    }

    return maximums;
}

float* StatManager::getStandardDeviations() {
    float* deviations = new float[numPins];

    for (int i = 0; i < numPins; ++i) {
        deviations[i] = 0;
        if (counts[i] > 1) {
            float mean = static_cast<float>(values[i]) / counts[i];
            float squaredDiffSum = 0;
            for (int j = 0; j < counts[i]; ++j) {
                float diff = static_cast<float>(pinValues[j]) - mean;
                squaredDiffSum += diff * diff;
            }
            deviations[i] = sqrt(squaredDiffSum / (counts[i] - 1));
        }
    }

    return deviations;
}

float* StatManager::getVariances() {
    float* variances = new float[numPins];

    for (int i = 0; i < numPins; ++i) {
        variances[i] = 0;
        if (counts[i] > 1) {
            float mean = static_cast<float>(values[i]) / counts[i];
            float squaredDiffSum = 0;
            for (int j = 0; j < counts[i]; ++j) {
                float diff = static_cast<float>(pinValues[j]) - mean;
                squaredDiffSum += diff * diff;
            }
            variances[i] = squaredDiffSum / (counts[i] - 1);
        }
    }

    return variances;
}
